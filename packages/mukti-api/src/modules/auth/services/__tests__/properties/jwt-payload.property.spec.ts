import { ConfigService } from '@nestjs/config';
import { JwtModule, JwtService } from '@nestjs/jwt';
import { Test, type TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { type JwtPayload, JwtTokenService } from '../../jwt.service';

/**
 * Property-Based Tests for JWT Payload Contents
 *
 * Feature: auth-system, Property 26: JWT payload contains required fields
 * Validates: Requirements 10.1
 *
 * These tests ensure that every JWT generated by the service includes the
 * required claims (sub, email, role, iat, exp) for both access and refresh
 * tokens.
 */
describe('JwtTokenService - Property 26: JWT payload contains required fields', () => {
  let service: JwtTokenService;
  let jwtService: JwtService;

  const configValues = {
    JWT_EXPIRES_IN: '15m',
    JWT_REFRESH_EXPIRES_IN: '7d',
    JWT_REFRESH_SECRET: 'property-refresh-secret',
    JWT_SECRET: 'property-access-secret',
  };

  const hexLikeString = (min: number, max: number) =>
    fc
      .array(
        fc.constantFrom(
          'a',
          'b',
          'c',
          'd',
          'e',
          'f',
          '0',
          '1',
          '2',
          '3',
          '4',
          '5',
          '6',
          '7',
          '8',
          '9',
        ),
        { maxLength: max, minLength: min },
      )
      .map((chars) => chars.join(''));

  const userPayloadArb = fc.record({
    email: fc
      .tuple(hexLikeString(3, 12), hexLikeString(3, 8))
      .map(([local, domain]) => `${local}@${domain}.com`),
    role: fc.constantFrom('user', 'admin', 'moderator'),
    sub: fc.string({ maxLength: 24, minLength: 6 }),
  });

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [
        JwtModule.register({
          secret: configValues.JWT_SECRET,
          signOptions: {
            issuer: 'mukti-api',
          },
        }),
      ],
      providers: [
        JwtTokenService,
        {
          provide: ConfigService,
          useValue: {
            get: (key: string) => configValues[key],
          },
        },
      ],
    }).compile();

    service = module.get<JwtTokenService>(JwtTokenService);
    jwtService = module.get<JwtService>(JwtService);
  });

  it('should include required claims in generated access tokens', async () => {
    await fc.assert(
      fc.asyncProperty(userPayloadArb, async (payload) => {
        const token = service.generateAccessToken(payload);

        const decoded = jwtService.verify<JwtPayload>(token, {
          issuer: 'mukti-api',
        });

        expect(decoded.sub).toBe(payload.sub);
        expect(decoded.email).toBe(payload.email);
        expect(decoded.role).toBe(payload.role);
        expect(typeof decoded.iat).toBe('number');
        expect(typeof decoded.exp).toBe('number');
        expect(decoded.exp).toBeGreaterThan(decoded.iat);

        return Promise.resolve();
      }),
      { numRuns: 25 },
    );
  });

  it('should include required claims in generated refresh tokens', async () => {
    await fc.assert(
      fc.asyncProperty(userPayloadArb, async (payload) => {
        const token = service.generateRefreshToken(payload);

        const decoded = jwtService.verify<JwtPayload>(token, {
          issuer: 'mukti-api',
          secret: configValues.JWT_REFRESH_SECRET,
        });

        expect(decoded.sub).toBe(payload.sub);
        expect(decoded.email).toBe(payload.email);
        expect(decoded.role).toBe(payload.role);
        expect(typeof decoded.iat).toBe('number');
        expect(typeof decoded.exp).toBe('number');
        expect(decoded.exp).toBeGreaterThan(decoded.iat);

        return Promise.resolve();
      }),
      { numRuns: 25 },
    );
  });
});
