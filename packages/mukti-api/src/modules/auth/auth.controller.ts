import type { Request, Response } from 'express';

import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Ip,
  Logger,
  Param,
  Patch,
  Post,
  Req,
  Res,
  UseGuards,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiTags } from '@nestjs/swagger';

import type {
  AuthResponseDto,
  ChangePasswordDto,
  ForgotPasswordDto,
  LoginDto,
  RegisterDto,
  ResetPasswordDto,
  TokenResponseDto,
  UserResponseDto,
  VerifyEmailDto,
} from './dto';

import { CurrentUser } from './decorators/current-user.decorator';
import { Public } from './decorators/public.decorator';
import {
  ApiChangePassword,
  ApiForgotPassword,
  ApiGetCsrfToken,
  ApiGetMe,
  ApiGetSessions,
  ApiGoogleAuth,
  ApiGoogleCallback,
  ApiLogin,
  ApiLogout,
  ApiLogoutAll,
  ApiRefresh,
  ApiRegister,
  ApiResendVerification,
  ApiResetPassword,
  ApiRevokeAllSessions,
  ApiRevokeSession,
  ApiVerifyEmail,
} from './dto/auth.swagger';
import { LoginRateLimitGuard } from './guards/login-rate-limit.guard';
import { PasswordResetRateLimitGuard } from './guards/password-reset-rate-limit.guard';
import { AuthService } from './services/auth.service';
import { OAuthProfile, OAuthService } from './services/oauth.service';
import { SessionService } from './services/session.service';

/**
 * Controller responsible for authentication endpoints.
 * Handles user registration, login, token refresh, logout, password reset, and email verification.
 *
 * @remarks
 * All endpoints except /me are public and don't require authentication.
 * Rate limiting is applied to login and password reset endpoints.
 */
@ApiTags('Authentication')
@Controller('auth')
export class AuthController {
  private readonly logger = new Logger(AuthController.name);

  constructor(
    private readonly authService: AuthService,
    private readonly sessionService: SessionService,
    private readonly oauthService: OAuthService,
  ) {}

  /**
   * Changes the current user's password
   *
   * @param userId - The current user ID from JWT
   * @param dto - Change password request data
   * @returns Success message
   */
  @ApiChangePassword()
  @HttpCode(HttpStatus.OK)
  @Patch('change-password')
  async changePassword(
    @CurrentUser('_id') userId: string,
    @Body() dto: ChangePasswordDto,
  ): Promise<{ message: string }> {
    this.logger.log(`Password change request for user ${userId}`);
    await this.authService.changePassword(userId.toString(), dto);
    return { message: 'Password changed successfully' };
  }

  /**
   * Initiates the password reset process
   *
   * @param dto - Forgot password request data
   * @param ip - Client IP address for rate limiting
   * @returns Success message
   */
  @ApiForgotPassword()
  @HttpCode(HttpStatus.OK)
  @Post('forgot-password')
  @Public()
  @UseGuards(PasswordResetRateLimitGuard)
  async forgotPassword(
    @Body() dto: ForgotPasswordDto,
    @Ip() ip: string,
  ): Promise<{ message: string }> {
    this.logger.log(`Password reset request from IP ${ip}`);
    await this.authService.incrementPasswordResetAttempt(dto.email);
    await this.authService.forgotPassword(dto);
    return {
      message: 'If the email exists, a password reset link has been sent',
    };
  }

  /**
   * Gets CSRF token for the client
   *
   * @param req - Express request object with CSRF token
   * @returns CSRF token
   *
   * @remarks
   * This endpoint provides the CSRF token that clients need to include
   * in state-changing requests (POST, PUT, PATCH, DELETE).
   * The token should be included in the X-CSRF-Token header.
   */
  @ApiGetCsrfToken()
  @Get('csrf-token')
  @HttpCode(HttpStatus.OK)
  @Public()
  getCsrfToken(@Req() req: Request): { csrfToken: string } {
    // The CSRF token is automatically generated by the csurf middleware
    // and attached to the request object
    const csrfToken = (req as any).csrfToken?.() ?? '';
    return { csrfToken };
  }

  /**
   * Gets the current authenticated user
   *
   * @param userId - The current user ID from JWT
   * @returns Current user information
   */
  @ApiGetMe()
  @Get('me')
  async getMe(@CurrentUser('_id') userId: string): Promise<UserResponseDto> {
    this.logger.log(`Get current user request for user ${userId}`);

    // Find user by ID
    const user = await this.authService.userModel.findById(userId).lean();

    if (!user) {
      throw new Error('User not found');
    }

    return {
      createdAt: user.createdAt,
      email: user.email,
      emailVerified: user.emailVerified,
      firstName: user.firstName,
      id: user._id.toString(),
      isActive: user.isActive,
      lastLoginAt: user.lastLoginAt,
      lastName: user.lastName,
      phone: user.phone,
      role: user.role,
      updatedAt: user.updatedAt,
    };
  }

  /**
   * Lists all active sessions for the current user
   *
   * @param userId - The current user ID from JWT
   * @returns Array of active sessions with device, location, and last activity information
   */
  @ApiGetSessions()
  @Get('sessions')
  async getSessions(@CurrentUser('_id') userId: string) {
    this.logger.log(`Get sessions request for user ${userId}`);
    const sessions = await this.sessionService.getUserSessions(
      userId.toString(),
    );
    return {
      data: sessions,
      success: true,
    };
  }

  /**
   * Initiates Google OAuth flow
   *
   * @remarks
   * Redirects user to Google's OAuth consent screen
   */
  @ApiGoogleAuth()
  @Get('google')
  @Public()
  @UseGuards(AuthGuard('google'))
  async googleAuth(): Promise<void> {
    // Guard redirects to Google
  }

  /**
   * Handles Google OAuth callback
   *
   * @param req - Express request object with user profile from Google
   * @param ip - Client IP address for session tracking
   * @param res - Express response object for setting cookies
   * @returns Authentication response with tokens and user data
   */
  @ApiGoogleCallback()
  @Get('google/callback')
  @Public()
  @UseGuards(AuthGuard('google'))
  async googleCallback(
    @Req() req: Request & { user?: unknown },
    @Ip() ip: string,
    @Res({ passthrough: true }) res: Response,
  ): Promise<AuthResponseDto> {
    this.logger.log(`Google OAuth callback from IP ${ip}`);

    // Extract user profile from request (set by GoogleStrategy)
    const profile = req.user as OAuthProfile;

    if (!profile) {
      throw new Error('User profile not found in request');
    }

    // Get device info
    const deviceInfo = req.headers['user-agent'] ?? 'Unknown device';

    // Authenticate with Google
    const result = await this.oauthService.authenticateWithGoogle(
      profile,
      deviceInfo,
      ip,
    );

    // Set refresh token in httpOnly cookie
    res.cookie(
      'refreshToken',
      result.refreshToken,
      this.getCookieOptions(7 * 24 * 60 * 60 * 1000), // 7 days
    );

    return result;
  }

  /**
   * Authenticates a user with email and password
   *
   * @param dto - Login credentials
   * @param ip - Client IP address for rate limiting
   * @param req - Express request object for device info
   * @param res - Express response object for setting cookies
   * @returns Authentication response with tokens and user data
   */
  @ApiLogin()
  @HttpCode(HttpStatus.OK)
  @Post('login')
  @Public()
  @UseGuards(LoginRateLimitGuard)
  async login(
    @Body() dto: LoginDto,
    @Ip() ip: string,
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ): Promise<AuthResponseDto> {
    this.logger.log(`Login attempt from IP ${ip}`);

    // Increment login attempt for rate limiting
    await this.authService.incrementLoginAttempt(ip);

    // Authenticate user
    const result = await this.authService.login(dto);

    // Reset rate limit on successful login
    await this.authService.resetLoginRateLimit(ip);

    // Calculate expiration based on rememberMe
    const rememberMe = dto.rememberMe ?? false;
    const expirationTime = rememberMe
      ? 30 * 24 * 60 * 60 * 1000 // 30 days
      : 24 * 60 * 60 * 1000; // 1 day

    // Create session record
    const deviceInfo = req.headers['user-agent'] ?? 'Unknown device';
    const refreshTokenExpires = new Date(Date.now() + expirationTime);

    await this.sessionService.createSession({
      deviceInfo,
      expiresAt: refreshTokenExpires,
      ipAddress: ip,
      refreshToken: result.refreshToken,
      userAgent: deviceInfo,
      userId: result.user.id,
    });

    // Set refresh token in httpOnly cookie
    res.cookie(
      'refreshToken',
      result.refreshToken,
      this.getCookieOptions(expirationTime),
    );

    return result;
  }

  /**
   * Logs out the current user
   *
   * @param userId - The current user ID from JWT
   * @param req - Express request object for refresh token
   * @param res - Express response object for clearing cookies
   */
  @ApiLogout()
  @HttpCode(HttpStatus.NO_CONTENT)
  @Post('logout')
  async logout(
    @CurrentUser('_id') userId: string,
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ): Promise<void> {
    this.logger.log(`Logout request for user ${userId}`);

    // Get refresh token from cookie
    const refreshToken = (req.cookies as Record<string, string> | undefined)
      ?.refreshToken;

    if (refreshToken) {
      await this.authService.logout(userId.toString(), refreshToken);
      await this.sessionService.revokeSessionByToken(refreshToken);
    }

    // Clear refresh token cookie
    res.clearCookie('refreshToken', this.getCookieOptions());
  }

  /**
   * Logs out the user from all devices
   *
   * @param userId - The current user ID from JWT
   * @param req - Express request object for current refresh token
   * @param res - Express response object for clearing cookies
   */
  @ApiLogoutAll()
  @HttpCode(HttpStatus.NO_CONTENT)
  @Post('logout-all')
  async logoutAll(
    @CurrentUser('_id') userId: string,
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ): Promise<void> {
    this.logger.log(`Logout all devices request for user ${userId}`);

    // Get current refresh token from cookie
    const currentRefreshToken = (
      req.cookies as Record<string, string> | undefined
    )?.refreshToken;

    // Revoke all sessions except current
    await this.sessionService.revokeAllSessions(
      userId.toString(),
      currentRefreshToken,
    );

    // Clear refresh token cookie
    res.clearCookie('refreshToken', this.getCookieOptions());
  }

  /**
   * Refreshes an access token using a refresh token
   *
   * @param req - Express request object for refresh token
   * @returns New access token
   */
  @ApiRefresh()
  @HttpCode(HttpStatus.OK)
  @Post('refresh')
  @Public()
  async refresh(@Req() req: Request): Promise<TokenResponseDto> {
    this.logger.log('Token refresh request');

    // Get refresh token from cookie
    const refreshToken = (req.cookies as Record<string, string> | undefined)
      ?.refreshToken;

    if (!refreshToken) {
      throw new Error('Refresh token not found');
    }

    // Update session last activity
    await this.sessionService.updateLastActivity(refreshToken);

    return await this.authService.refresh(refreshToken);
  }

  /**
   * Registers a new user
   *
   * @param dto - User registration data
   * @param ip - Client IP address for session tracking
   * @param req - Express request object for device info
   * @param res - Express response object for setting cookies
   * @returns Authentication response with tokens and user data
   */
  @ApiRegister()
  @HttpCode(HttpStatus.CREATED)
  @Post('register')
  @Public()
  async register(
    @Body() dto: RegisterDto,
    @Ip() ip: string,
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response,
  ): Promise<AuthResponseDto> {
    this.logger.log(`Registration attempt from IP ${ip}`);

    // Register user
    const result = await this.authService.register(dto);

    // Create session record
    const deviceInfo = req.headers['user-agent'] ?? 'Unknown device';
    const refreshTokenExpires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await this.sessionService.createSession({
      deviceInfo,
      expiresAt: refreshTokenExpires,
      ipAddress: ip,
      refreshToken: result.refreshToken,
      userAgent: deviceInfo,
      userId: result.user.id,
    });

    // Set refresh token in httpOnly cookie
    res.cookie(
      'refreshToken',
      result.refreshToken,
      this.getCookieOptions(7 * 24 * 60 * 60 * 1000), // 7 days
    );

    return result;
  }

  /**
   * Resends the email verification email
   *
   * @param body - Request body with email
   * @returns Success message
   */
  @ApiResendVerification()
  @HttpCode(HttpStatus.OK)
  @Post('resend-verification')
  @Public()
  async resendVerification(
    @Body() body: { email: string },
  ): Promise<{ message: string }> {
    this.logger.log(`Resend verification request for ${body.email}`);
    await this.authService.resendVerification(body.email);
    return { message: 'Verification email sent successfully' };
  }

  /**
   * Resets a user's password using a reset token
   *
   * @param dto - Reset password request data
   * @returns Success message
   */
  @ApiResetPassword()
  @HttpCode(HttpStatus.OK)
  @Post('reset-password')
  @Public()
  async resetPassword(
    @Body() dto: ResetPasswordDto,
  ): Promise<{ message: string }> {
    this.logger.log('Password reset attempt with token');
    await this.authService.resetPassword(dto);
    return { message: 'Password reset successfully' };
  }

  /**
   * Revokes all sessions except the current one
   *
   * @param userId - The current user ID from JWT
   * @param req - Express request object for current refresh token
   */
  @ApiRevokeAllSessions()
  @Delete('sessions/all')
  @HttpCode(HttpStatus.NO_CONTENT)
  async revokeAllSessionsEndpoint(
    @CurrentUser('_id') userId: string,
    @Req() req: Request,
  ): Promise<void> {
    this.logger.log(`Revoke all sessions request for user ${userId}`);

    // Get current refresh token from cookie
    const currentRefreshToken = (
      req.cookies as Record<string, string> | undefined
    )?.refreshToken;

    // Revoke all sessions except current
    await this.sessionService.revokeAllSessions(
      userId.toString(),
      currentRefreshToken,
    );
  }

  /**
   * Revokes a specific session by ID
   *
   * @param userId - The current user ID from JWT
   * @param sessionId - The session ID to revoke
   */
  @ApiRevokeSession()
  @Delete('sessions/:id')
  @HttpCode(HttpStatus.NO_CONTENT)
  async revokeSession(
    @CurrentUser('_id') userId: string,
    @Param('id') sessionId: string,
  ): Promise<void> {
    this.logger.log(`Revoke session ${sessionId} request for user ${userId}`);
    await this.sessionService.revokeSession(sessionId, userId.toString());
  }

  /**
   * Verifies a user's email address
   *
   * @param dto - Email verification request data
   * @returns Success message
   */
  @ApiVerifyEmail()
  @HttpCode(HttpStatus.OK)
  @Post('verify-email')
  @Public()
  async verifyEmail(@Body() dto: VerifyEmailDto): Promise<{ message: string }> {
    this.logger.log('Email verification attempt with token');
    await this.authService.verifyEmail(dto);
    return { message: 'Email verified successfully' };
  }

  private getCookieOptions(maxAge?: number) {
    return {
      domain:
        process.env.NODE_ENV === 'production' ? '.mukti.live' : 'localhost',
      httpOnly: true,
      maxAge,
      sameSite: 'strict' as const,
      secure: process.env.NODE_ENV === 'production',
    };
  }
}
